import type { DedupeResult } from '#interfaces/DedupeResult';
import type { AxiosResponse } from 'axios';

/**
 * Manages request deduplication to prevent multiple identical HTTP requests
 * from being sent simultaneously. When multiple requests with the same cache key
 * are made, only the first request is actually sent, and all subsequent requests
 * receive the same response.
 *
 * The cache key is generated using the `getCacheKey()` method from JinFrame instances,
 * which creates a unique identifier based on the request parameters and configuration.
 */
export class RequestDedupeManager {
  /** Store pending requests (key: cacheKey, value: Promise) */
  private static pendingRequests = new Map<string, Promise<AxiosResponse<unknown>>>();

  /**
   * Deduplicates HTTP requests based on cache key. If a request with the same
   * cache key is already in progress, returns the result of that request.
   * Otherwise, executes the new request and stores it for potential deduplication.
   *
   * @template T - The expected response data type
   * @param cacheKey - Unique identifier for the request used for deduplication (generated by JinFrame.getCacheKey())
   * @param requesterFn - Function that performs the actual HTTP request
   * @returns Promise resolving to DedupeResult containing the response and deduplication flag
   *
   * @example
   * ```ts
   * // Cache key is typically generated by JinFrame.getCacheKey()
   * const frame = GetUserFrame.of({ id: '123' });
   * const cacheKey = frame.getCacheKey();
   *
   * const result = await RequestDedupeManager.dedupe(
   *   cacheKey,
   *   () => axios.get('/users/123')
   * );
   * console.log(result.isDeduped); // false for original request, true for duplicates
   * ```
   */
  static async dedupe<T>(cacheKey: string, requesterFn: () => Promise<AxiosResponse<T>>): Promise<DedupeResult<T>> {
    const existingPromise = this.pendingRequests.get(cacheKey);
    if (existingPromise) {
      const response = (await existingPromise) as AxiosResponse<T>;
      return { reply: response, isDeduped: true };
    }

    // Create new request and register it in pendingRequests first
    const promise = requesterFn()
      .then((reply) => {
        // Safely remove from pending on success
        this.pendingRequests.delete(cacheKey);
        return reply;
      })
      .catch((error) => {
        // Safely remove from pending on failure as well
        this.pendingRequests.delete(cacheKey);
        throw error;
      });

    // Prevent race condition: register promise immediately after creation
    this.pendingRequests.set(cacheKey, promise);

    const reply = await promise;
    return { reply, isDeduped: false };
  }

  /**
   * Returns the number of currently pending requests.
   * Useful for debugging and monitoring request deduplication.
   *
   * @returns The count of pending requests
   */
  static getPendingRequestsCount(): number {
    return this.pendingRequests.size;
  }

  /**
   * Clears all pending requests from the cache.
   * This method is primarily intended for testing purposes.
   *
   * @warning Use with caution in production as this will affect all pending requests
   */
  static clearAllPendingRequests(): void {
    this.pendingRequests.clear();
  }

  /**
   * Checks if a request with the given cache key is currently pending.
   *
   * @param cacheKey - The cache key to check
   * @returns true if a request with this cache key is pending, false otherwise
   */
  static hasPendingRequest(cacheKey: string): boolean {
    return this.pendingRequests.has(cacheKey);
  }
}
